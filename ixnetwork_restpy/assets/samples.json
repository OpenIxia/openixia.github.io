[
    {
        "name": "Assistants",
        "children": [
            {
                "name": "port_map_assistant.py",
                "content": "\"\"\"Demonstrates how to use the PortMapAssistant class\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# demonstrate different ways to add mappings between test port locations and vport names\n# if the vport name does not exist a new vport using that name will be created and mapped\n# if the vport name is None then a new vport will be created using the system's default naming scheme and mapped\nport_map = session_assistant.PortMapAssistant()\nport_map.Map(Location=\"10.36.74.26;2;11\", Name=\"Port 1\")\nport_map.Map(\"10.36.74.26\", 2, 12, Name=\"Port 2\")\nport_map.Map(IpAddress=\"10.36.74.26\", CardId=2, PortId=13, Name=\"Port 3\")\nport_map.Map(Port=(\"10.36.74.26\", 2, 14), Name=\"Port 4\")\nprint(port_map)\n\n# using the map connect test port locations and vports\nport_map.Connect(ForceOwnership=True, HostReadyTimeout=20, LinkUpTimeout=60)\nprint(port_map)\n\n# using the map disconnect test port locations and vports\nport_map.Disconnect()\nprint(port_map)\n"
            },
            {
                "name": "Batch",
                "children": [
                    {
                        "name": "Batch_add",
                        "children": [
                            {
                                "name": "batch_add.py",
                                "content": "\"\"\"\nbatch_add.py:\n\n    - Connect to the API server\n    - In a BatchAdd call, do the following:\n        - Add two vports\n        - Add two topologies using these vports\n        - Add two device groups in the first topology\n        - Add Ethernet protocol to both the device groups\n        - Add Ipv4 to the first device group, and Ipv6 to the second\n        - Add two device groups in the second topology\n        - Add Ethernet & Ipv4 protocols to both the device groups\n        - Add BgpIpv4Peer to the first device group, and Ospfv2 to the second\n    - In another BatchAdd call, do the following:\n        - Add two more vports\n        - Add two more topologies using these newly added vports\n        - Add a device group in the last topology\n        \nSupports IxNetwork API servers:\n   - Windows, Windows Connection Mgr and Linux\n   \nRequirements:\n   - Minimum IxNetwork 9.10\n   - Python 2.7 and 3+\n   - pip install requests\n   - pip install ixnetwork_restpy (minimum version 1.1.5)\n   \nRestPy Doc:\n    https://openixia.github.io/ixnetwork_restpy/#/overview\n\nUsage:\n   - Enter: python <script>\n   \n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, BatchAdd\n\n\n# create a test tool session\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# Generally, BatchAdd is used to configure a bunch of resources in a single rest call\nwith BatchAdd(ixnetwork):\n    vp = ixnetwork.Vport.add(Name=\"vp1\").add(Name=\"vp2\")\n    ixnetwork.Topology.add(Vports=vp[0]).add(Vports=vp[1])\n    dg = ixnetwork.Topology[0].DeviceGroup.add().add()\n    dg[0].Ethernet.add().Ipv4.add()\n    dg[1].Ethernet.add().Ipv6.add()\n    dg = ixnetwork.Topology[1].DeviceGroup.add().add()\n    dg[0].Ethernet.add().Ipv4.add().BgpIpv4Peer.add(Name=\"Bgp1\")\n    dg[1].Ethernet.add().Ipv4.add().Ospfv2.add(Name=\"ospf-100.1.0.2\")\n\n\n# Note: BatchAdd  can be used multiple times in the same script\nwith BatchAdd(ixnetwork):\n    vp.add(Name=\"vp3\").add(Name=\"vp4\")\n    topo = ixnetwork.Topology.add(Vports=vp[2]).add(Vports=vp[3])\n    topo[-1].DeviceGroup.add(Name=\"my_dg\")\n"
                            },
                            {
                                "name": "traffic_with_batch_add.py",
                                "content": "\"\"\"\ntraffic_with_batch_add.py:\n\n    - Connect to the API server\n    - In a BatchAdd call, do the following:\n        - Add two vports\n        - Update some attributes of the vports\n        - Add a raw traffic item\n        - Add endpoint set, config element and stack to it\n        - Add Ethernet, DHCP, Ipv4 & Igmpv1 protocols to the stack\n        - Update various attributes of each of these\n        \nSupports IxNetwork API servers:\n   - Windows, Windows Connection Mgr and Linux\n   \nRequirements:\n   - Minimum IxNetwork 9.10\n   - Python 2.7 and 3+\n   - pip install requests\n   - pip install ixnetwork_restpy (minimum version 1.1.5)\n   \nRestPy Doc:\n    https://openixia.github.io/ixnetwork_restpy/#/overview\n\nUsage:\n   - Enter: python <script>\n   \n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, BatchAdd\n\n\n# create a test tool session\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# we will be configuring traffic using batch add\n# please note that its a bit different and easier from our regular traffic configuration\nwith BatchAdd(ixnetwork):\n    vport = ixnetwork.Vport.add().add()\n    vport[0].Name = \"myVport_1\"\n    vport[0].RxMode = \"captureAndMeasure\"\n    vport[1].Name = \"myVport_2\"\n    traffic = ixnetwork.Traffic.TrafficItem\n    tr1 = traffic.add(\n        Name=\"RAW TCP\", BiDirectional=False, TrafficType=\"raw\", TrafficItemType=\"l2L3\"\n    )\n    tr1.EndpointSet.add(\n        Sources=vport[0].Protocols.add(), Destinations=vport[1].Protocols.add()\n    )\n    stack = tr1.ConfigElement.add().Stack.add()\n    eth_st = stack.Ethernet.add()\n    eth_st.SourceAddress.Single(\"00:11:00:00:22:00\")\n    eth_st.DestinationAddress.Single(\"00:33:00:11:22:00\")\n    dhcp_st = stack.Dhcp.add()\n    dhcp_st.OpCode.Single(2)\n    dhcp_st.HwType.Single(5)\n    dhcp_st.BroadcastFlag.Single(32768)\n    dhcp_st.ServerIP.Increment(\"1.2.3.4\", \"0.2.1.0\")\n    dhcp_st.ClientIP.Decrement(\"12.13.14.15\", \"0.0.0.1\")\n    dhcp_st.ClientHwAddress.Single(\"0aaa\")\n    ipv4_st = stack.Ipv4.add()\n    ipv4_st.TosDelay.Single(1)\n    ipv4_st.TosPrecedence.Single(3)\n    ipv4_st.Checksum.Increment(2, 4)\n    igmp_st = stack.Igmpv1.add()\n    igmp_st.Type.Single(1)\n    igmp_st.Unused.Single(\"0xcc\")\n    ip_list = [\"1.2.3.4\", \"1.22.31.4\", \"1.12.3.4\", \"1.4.3.4\"]\n    igmp_st.GroupAddress.ValueList(ip_list)\n"
                            }
                        ]
                    },
                    {
                        "name": "Batch_find",
                        "children": [
                            {
                                "name": "batch_find.py",
                                "content": "\"\"\"\nbatch_find.py:\n\n    - Connect to the API server\n    - Add 5 vports\n    - Add 5 interfaces for each vport with enabled Vlan for some\n    - Use BatchFind call to find all the vports, interfaces and vlans with enabled vlan\n    - Update few attributes using the result found by BatchFind\n    - Update attributes for the parent of any node found\n    - Add two topologies\n    - Add 5 device groups in each topology\n    - Use BatchFind call to find the device groups of second topology only\n    - Update attributes for the result found by the BatchFind\n        \nSupports IxNetwork API servers:\n   - Windows, Windows Connection Mgr and Linux\n   \nRequirements:\n   - Minimum IxNetwork 9.00\n   - Python 2.7 and 3+\n   - pip install requests\n   - pip install ixnetwork_restpy (minimum version 1.1.5)\n   \nRestPy Doc:\n    https://openixia.github.io/ixnetwork_restpy/#/overview\n\nUsage:\n   - Enter: python <script>\n   \n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, BatchFind\n\n\n# create a test tool session\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# adding certain vports and interfaces underneath them\nfor _ in range(0, 5):\n    vport = ixnetwork.Vport.add()\n    for vlan_id in range(0, 5):\n        vport.Interface.add(Enabled=True).Vlan.VlanEnable = vlan_id % 2 == 0\n\n# when you have a huge config with a lot of nodes, batch find will actually help to find nodes ver quickly,\n# hence giving better performance result than normal find\n# using batch find to find the respective restPy nodes\nwith BatchFind(ixnetwork) as bf:\n    ixnetwork.Vport.find().Interface.find().Vlan.find(VlanEnable=True)\n\n# the batch find object bf has a results object which has a list of restPy nodes with their names\n# here we are changing the some attributes of the found nodes.\nbf.results.vport[1].Name = \"my_vport\"\nbf.results.interface[2].Description = \"my_interface_description\"\nbf.results.vlan[3].VlanId = 100\n\n# the restPy nodes maintains the same hierarchy when batch find is used.\n# here we will be disabling the parent interface for a vlan node condition.\nbf.results.vlan[6].parent.Enabled = False\n\ntopologies = ixnetwork.Topology.add().add()\nfor topology in topologies:\n    for _ in range(0, 5):\n        topology.DeviceGroup.add()\n\n# one point to note.\n# You need to pass the parent node in batchFind for which you want to find the children of.\nwith BatchFind(topologies[1]) as bf:\n    topologies[1].DeviceGroup.find()\n\nbf.results.deviceGroup[3].Multiplier = 100\n"
                            }
                        ]
                    },
                    {
                        "name": "Batch_update",
                        "children": [
                            {
                                "name": "batch_update.py",
                                "content": "\"\"\"\nbatch_update.py:\n\n    - Connect to the API server\n    - Add 10 vports\n    - Update few attributes of all the vports using BatchUpdate\n    - Add a topology\n    - Add 5 device groups to this topology\n    - Find the device groups\n    - Update any multivalue attribute of the device groups using BatchUpdate\n        \nSupports IxNetwork API servers:\n   - Windows, Windows Connection Mgr and Linux\n   \nRequirements:\n   - Minimum IxNetwork 9.00\n   - Python 2.7 and 3+\n   - pip install requests\n   - pip install ixnetwork_restpy (minimum version 1.1.5)\n   \nRestPy Doc:\n    https://openixia.github.io/ixnetwork_restpy/#/overview\n\nUsage:\n   - Enter: python <script>\n   \n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, BatchUpdate\n\n\n# create a test tool session\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\nvports = ixnetwork.Vport\n\n# adding few vports\nfor i in range(0, 10):\n    vports.add()\n\n# updating properties of vports using batch update.\n# batch update basically batches all the update operations and updates those in one go, thereby giving us a little better\n# performance that the normal update function\nwith BatchUpdate(ixnetwork):\n    for vport in vports:\n        vport.Name = vport.href\n        vport.TxMode = \"sequential\"\n        vport.RxMode = \"captureAndMeasure\"\n        vport.TraceEnabled = False\n        vport.Type = \"novusHundredGigLan\"\n\n\n# adding topology and a few device groups\ntopology = ixnetwork.Topology.add()\nfor _ in range(0, 5):\n    topology.DeviceGroup.add()\n\n# batch update also supports multivalue updates\n# below example we are updating enable multiValue property in device groups\ndevice_groups = topology.DeviceGroup.find()\nwith BatchUpdate(ixnetwork):\n    for device_group in device_groups:\n        device_group.Enabled.Single(False)\n"
                            },
                            {
                                "name": "load_config_with_batch_update.py",
                                "content": "\"\"\"\nload_config_with_batch_update.py:\n\n    - Connect to the API server\n    - Load a saved configuration\n    - Find all the traffic items in the configuration\n    - Update few attributes of all the traffic items & their config elements using BatchUpdate\n        \nSupports IxNetwork API servers:\n   - Windows, Windows Connection Mgr and Linux\n   \nRequirements:\n   - Minimum IxNetwork 9.20\n   - Python 2.7 and 3+\n   - pip install requests\n   - pip install ixnetwork_restpy (minimum version 1.1.5)\n   \nRestPy Doc:\n    https://openixia.github.io/ixnetwork_restpy/#/overview\n\nUsage:\n   - Enter: python <script>\n   \n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, BatchUpdate, Files\n\n\n# create a test tool session\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# loading a config to our ixnetwork server\nixnetwork.LoadConfig(Files(r\"load.ixncfg\"))\n\n# finding all the traffic items in our config\ntraffic_items = ixnetwork.Traffic.TrafficItem.find()\n\n# we are using batch update to update some traffic parameters and parameters of its sub child\nwith BatchUpdate(ixnetwork):\n    for idx, traffic_item in enumerate(traffic_items):\n        traffic_item.Name = \"my_traffic_\" + str(idx)\n        configElement = traffic_item.ConfigElement.find()\n        configElement.FrameRate.Type = \"percentLineRate\"\n        configElement.FrameRate.Rate = 50\n        configElement.TransmissionControl.Type = \"fixedFrameCount\"\n        configElement.TransmissionControl.FrameCount = 100000\n        configElement.FrameRateDistribution.PortDistribution = \"splitRateEvenly\"\n        configElement.FrameSize.FixedSize = 1280\n        traffic_item.Tracking.find().TrackBy = [\"trafficGroupId0\"]\n"
                            }
                        ]
                    }
                ]
            },
            {
                "name": "Stat_view_assistant",
                "children": [
                    {
                        "name": "filter_stats_using_stat_view_assistant.py",
                        "content": "\"\"\"\nDemonstrates how to use the StatViewAssist class to get stats based on a particular filter type.\nFilterType can be used to define the high level scope on which view we want the filter.\nFilterView property of StatViewAssist can then be used to add more customised filter options according to need.\nFinally, calling GetFilteredStats method returns us an instance of StatViewAssist with statics for the filtered view populated.\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, StatViewAssistant\n\n# connecting to an existing session where traffic is running\ns = SessionAssistant(IpAddress=\"127.0.0.1\", RestPort=11009, ClearConfig=False)\nixn = s.Ixnetwork\n\n# providing the name of the new filter_view and the type of filter we need to impose on that view\nsv = StatViewAssistant(ixn, \"filter_flow\", FilterType=\"layer23TrafficFlow\")\n\n# customise filter options according to need\nflowFilterObj = sv.FilterView.Layer23TrafficFlowFilter.find()\nflowFilterObj.AggregatedAcrossPorts = True\n\n\navailablePortFilter = sv.FilterView.AvailablePortFilter.find()\navailableTrafficItemFilter = sv.FilterView.AvailableTrafficItemFilter.find()\n\n# set the port and traffic filters\nflowFilterObj.PortFilterIds = availablePortFilter\nflowFilterObj.TrafficItemFilterIds = availableTrafficItemFilter\n\nfor filter in flowFilterObj.EnumerationFilters.find():\n    filter.Enabled = True\n    filter.SortDirection = \"ascending\"\n\n# GetFilteredStats returns a new instance of statViewAssistant with statics for the filtered view populated\nprint(sv.GetFilteredStats())\n"
                    },
                    {
                        "name": "stat_view_assistant.py",
                        "content": "\"\"\"Demonstrates how to use the StatViewAssist class\n\nThis sample requires an already loaded configuration with at least 2 connected vports.\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, StatViewAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=False,\n)\nixnetwork = session_assistant.Ixnetwork\n\nixnetwork.info(\"negative test\")\ntry:\n    session_assistant.StatViewAssistant(\"my test view\", Timeout=5)\nexcept Exception as e:\n    ixnetwork.info(e)\n\n# get a list of all current statistic views that can be used in the StatViewAssistant\nprint(StatViewAssistant.GetViewNames(ixnetwork))\n\n# create a stat view assistant for a statistics view\nport_statistics = session_assistant.StatViewAssistant(\"Port Statistics\")\n\n# print all the rows for a statistics view\nprint(port_statistics)\n\n# add a filter so that only a single row is retrieved\nport_statistics.AddRowFilter(\"Port Name\", StatViewAssistant.REGEX, \"Port 1$\")\nprint(port_statistics)\n\n# demonstrate cell access\nport_statistics.ClearRowFilters()\nrows = port_statistics.Rows\n\n# get the cell value at row 0, column 'Port Name'\nprint(rows[0][\"Port Name\"])\n\n# get the cell value at row 1, column 'Stat Name'\nprint(rows[1][\"Stat Name\"])\n\n# get the cell value at the first row that matches a regex of 'case insensitive endswith port 1', column 'Frames Tx.'\nprint(rows[\"(?i)port 1$\"][\"Frames Tx.\"])\n\nixnetwork.info(\"check that all ipv4 protocols are up\")\nprotocols_summary = session_assistant.StatViewAssistant(\"Protocols Summary\")\nprotocols_summary.AddRowFilter(\"Protocol Type\", StatViewAssistant.REGEX, \"(?i)^ipv4?\")\nprotocols_summary.CheckCondition(\"Sessions Not Started\", StatViewAssistant.EQUAL, 0)\nprotocols_summary.CheckCondition(\"Sessions Down\", StatViewAssistant.EQUAL, 0)\n\nixnetwork.info(\"traffic stat check\")\ntraffic_statistics = session_assistant.StatViewAssistant(\"Traffic Item Statistics\")\ntx_frames = traffic_statistics.Rows[0][\"Tx Frames\"]\nixnetwork.info(\"tx frames: %s\" % tx_frames)\n\nixnetwork.info(\"drilldown sample\")\nixnetwork.info(traffic_statistics.DrillDownOptions())\nixnetwork.info(traffic_statistics.TargetRowFilters())\ndrilldown = traffic_statistics.Drilldown(\n    0,\n    traffic_statistics.DrillDownOptions()[0],\n    traffic_statistics.TargetRowFilters()[0],\n)\nprint(drilldown)\n"
                    }
                ]
            }
        ]
    },
    {
        "name": "Basic",
        "children": [
            {
                "name": "async_operation.py",
                "content": "import time\nfrom ixnetwork_restpy import SessionAssistant\n\n\n# create a test tool session\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# setup test ports and virtual ports\nchassis_ip = \"10.39.51.187\"\ntest_ports = [\n    dict(Arg1=chassis_ip, Arg2=1, Arg3=9),\n    dict(Arg1=chassis_ip, Arg2=1, Arg3=10),\n]\nvirtual_ports = ixnetwork.Vport.add().add()\n\n# here we are assigning ports asynchronously using async_operation attribute\nixnetwork.info(\"Assigning ports asynchronously\")\nixnetwork.AssignPorts(test_ports, [], virtual_ports, True, async_operation=True)\n\n# now while the config is loading asynchronously we can do some other operations\n# generally we can do some DUT operations but here we are just doing some operation as an example\nixnetwork.info(\"Doing some other operations\")\nfor i in range(20):\n    print(\"operation \" + str(i + 1))\n    time.sleep(2)\n\n# finally we get the async response after doing some other operations\nixnetwork.info(\"Fetching the response of the asynchronous operation\")\nassigned_ports = ixnetwork.get_async_response()\nprint(\"connected ports = \" + str(assigned_ports))\n\nixnetwork.info(\"End\")\n"
            },
            {
                "name": "getting_started.py",
                "content": "\"\"\"This script demonstrates how to get started with ixnetwork_restpy scripting.\n\nThe script demonstrates the following:\n    - connect to an IxNetwork test platform, authenticate, add a new session and clear the config\n    - create 1 tx port and 1 rx port\n    - create traffic from the tx port to the rx port\n    - start traffic\n    - print statistics\n    - stop traffic\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\", LogLevel=SessionAssistant.LOGLEVEL_INFO, ClearConfig=True\n)\nixnetwork = session_assistant.Ixnetwork\n\n# create tx and rx port resources\nport_map = session_assistant.PortMapAssistant()\nport_map.Map(\"10.36.74.26\", 2, 13, Name=\"Tx\")\nport_map.Map(\"10.36.74.26\", 2, 14, Name=\"Rx\")\n\n# create a TrafficItem resource\n# TrafficItem acts a a high level container for ConfigElement resources\n# ConfigElement is a high level container for individual HighLevelStream resources\ntraffic_item = ixnetwork.Traffic.TrafficItem.add(Name=\"Traffic Test\", TrafficType=\"raw\")\ntraffic_item.EndpointSet.add(\n    Sources=ixnetwork.Vport.find(Name=\"^Tx\").Protocols.find(),\n    Destinations=ixnetwork.Vport.find(Name=\"^Rx\").Protocols.find(),\n)\n\n# using the traffic ConfigElement resource\n# update the frame rate\n# update the transmission control\ntraffic_config = traffic_item.ConfigElement.find()\ntraffic_config.FrameRate.update(Type=\"percentLineRate\", Rate=\"100\")\ntraffic_config.TransmissionControl.update(Type=\"continuous\")\n\n# adjust Ethernet stack fields\ndestination_mac = traffic_config.Stack.find(StackTypeId=\"ethernet\").Field.find(\n    FieldTypeId=\"ethernet.header.destinationAddress\"\n)\ndestination_mac.update(\n    ValueType=\"valueList\",\n    ValueList=[\"00:00:fa:ce:fa:ce\", \"00:00:de:ad:be:ef\"],\n    TrackingEnabled=True,\n)\n\n# push ConfigElement settings down to HighLevelStream resources\ntraffic_item.Generate()\n\n# connect ports to hardware test ports\n# apply traffic to hardware\n# start traffic\nport_map.Connect(ForceOwnership=True)\nixnetwork.Traffic.Apply()\nixnetwork.Traffic.StartStatelessTrafficBlocking()\n\n# print statistics\nprint(session_assistant.StatViewAssistant(\"Port Statistics\"))\nprint(session_assistant.StatViewAssistant(\"Traffic Item Statistics\"))\nprint(session_assistant.StatViewAssistant(\"Flow Statistics\"))\n\n# stop traffic\nixnetwork.Traffic.StopStatelessTrafficBlocking()\n"
            },
            {
                "name": "internal_requests_access.py",
                "content": "\"\"\"Demonstrates how to use the underlying requests connection\nto access an API that is not exposed in the python package \n\nBackground\n----------\nevery object has an internal _connection\nthe _connection has a .update .read .create .delete\nthose methods are raw requests access to the server so you need to \nuse API browser property names in the payload\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, Files\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\npreferences = session_assistant.Ixnetwork.Globals.Preferences\nurl = \"%s/debug/mw\" % preferences.href\npayload = {\"debugLog\": True, \"traceLevel\": \"all\"}\npreferences._connection._update(url, payload)\n"
            },
            {
                "name": "iterators.py",
                "content": "\"\"\"Demonstrates ixnetwork_restpy container object functionality.\n\nThe sample below shows how to retrieve all instances of a node from the server into a single container object\nEach instance can be accessed using the container object's iterator or index functionality\nThe container implements the following special method names to allow for iteration and indexing:\n    __len__, __getitem__, __iter__, __next__\n\nThe benefit of a container object is that a single method call can act on many instances without having to pass arrays of references.\nFor example if a container encapsulates 10 instances, the <container>.remove() method will delete all the encapsulated \ninstances without having to add looping code\n\nFor more information on containers read the following:  \n  https://docs.python.org/2.7/reference/datamodel.html#emulating-container-types\n  https://docs.python.org/2.7/library/stdtypes.html#typeiter\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# create x number of vports\nvport_count = 3\nfor i in range(vport_count):\n    ixnetwork.Vport.add()\n\n# get a container object with all instances\nvports = ixnetwork.Vport.find()\nassert len(vports) == 3\n\n# print the number of insances encapsulated in the container\nprint(\"%s instances\" % len(vports))\n\n# print all instances in the container\nprint(vports)\n\n# print the first instance\nprint(vports[0].href)\n\n# print the last instance\nprint(vports[-1].href)\n\n# convert the container object into a list\nvport_list = list(vports)\nprint(len(vport_list))\n\n# remove all encapsulated instances in a single method call\nvports.remove()\n"
            },
            {
                "name": "multivalues.py",
                "content": "\"\"\"Demonstrates different types of patterns that can be set in\n\tTestPlatform.Sessions.IxNetwork.Topology...Multivalue objects\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# add virtual ports\nvports = ixnetwork.Vport.add().add().add().add()\nvports.info(vports)\n\n# add ipv4 devices\nipv4 = (\n    ixnetwork.Topology.add(Ports=vports)\n    .DeviceGroup.add(Multiplier=10)\n    .Ethernet.add()\n    .Ipv4.add()\n)\n\n# set single multivalue\nipv4.Address.Single(\"6.6.6.6\")\nipv4.info(ipv4.Address)\nassert ipv4.Address.Pattern == \"6.6.6.6\"\n\n# add overlays\nipv4.Address.Overlay(3, \"1.2.3.4\")\nipv4.Address.Overlay(6, \"4.3.2.1\")\n\n# set increment multivalue\nipv4.Address.Increment(start_value=\"7.7.7.7\", step_value=\"8.8.8.8\")\nipv4.info(ipv4.Address)\nassert ipv4.Address.Pattern.startswith(\"Inc:\") is True\n\n# set decrement multivalue\nipv4.Address.Decrement(start_value=\"6.6.6.6\", step_value=\"5.5.5.5\")\nipv4.info(ipv4.Address)\nassert ipv4.Address.Pattern.startswith(\"Dec:\") is True\n\n# set custom multivalue\nipv4.Address.Custom(\n    start_value=\"6.6.6.6\",\n    step_value=\"5.5.5.5\",\n    increments=[(\"3.3.3.3\", 12, [(\"2.2.2.2\", 20, [])])],\n)\nipv4.info(ipv4.Address)\nassert ipv4.Address.Pattern.startswith(\"Custom:\") is True\n\n# set valuelist multivalue\nipv4.Address.ValueList([\"10.10.10.10\", \"11.11.11.11\"])\nipv4.info(ipv4.Address)\nassert ipv4.Address.Pattern.startswith(\"List:\") is True\n\n# set random multivalue\nipv4.Address.Random()\nipv4.info(ipv4.Address)\nassert ipv4.Address.Pattern.startswith(\"Rand\") is True\n\n# set repeatable random range multivalue\nipv4.Address.RandomRange(\n    min_value=\"1.1.1.1\", max_value=\"2.2.2.2\", step_value=\"0.0.0.1\", seed=7\n)\nipv4.info(ipv4.Address)\nassert ipv4.Address.Pattern.startswith(\"Randr:\") is True\n\n# set repeatable random multivalue\nipv4.Address.RandomMask(fixed_value=\"1.1.1.1\", mask_value=\"0.0.0.1\", seed=7, count=6)\nipv4.info(ipv4.Address)\nassert ipv4.Address.Pattern.startswith(\"Randb:\") is True\n"
            },
            {
                "name": "nest_multivalue.py",
                "content": "\"\"\"\nnest_Multivalue.py:\n\n   - Connect to the API server\n   - Configure one Topology\n   - Configure Device Group for topology\n   - Configure Network Group connected to Device Group\n   - From Network Group fetch all the nest for ipv4 prefix pools in multivalue network address\n   - Set different values for Nest multivalues\n\nRestPy Doc:\n    https://www.openixia.github.io/ixnetwork_restpy/#/\n\nUsage:\n   - Enter: python <script>\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\nsession = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    RestPort=11009,\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\n\nixNetwork = session.Ixnetwork\n\nixNetwork.info(\"Creating vport\")\nvport = ixNetwork.Vport.add()\n\nixNetwork.info(\"Creating Topology\")\ntopology1 = ixNetwork.Topology.add(Name=\"Topo1\", Ports=vport)\ndeviceGroup1 = topology1.DeviceGroup.add(Name=\"DG1\", Multiplier=\"1\")\nethernet1 = deviceGroup1.Ethernet.add(Name=\"Eth1\")\nethernet1.Mac.Increment(start_value=\"00:01:01:01:00:01\", step_value=\"00:00:00:00:00:01\")\n\nixNetwork.info(\"Configuring IPv4 on Topology\")\nipv4 = ethernet1.Ipv4.add(Name=\"Ipv4\")\nipv4.Address.Increment(start_value=\"1.1.1.1\", step_value=\"0.0.0.1\")\nipv4.GatewayIp.Increment(start_value=\"1.1.1.4\", step_value=\"0.0.0.0\")\n\nixNetwork.info(\"Configuring Network group behind Topology\")\nnetworkGroup1 = deviceGroup1.NetworkGroup.add(Name=\"NG1\", Multiplier=\"4\")\nipv4PrefixPool = networkGroup1.Ipv4PrefixPools.add(NumberOfAddresses=\"1\")\nipv4PrefixPool.NetworkAddress.Increment(start_value=\"20.10.0.1\", step_value=\"0.0.0.1\")\n\n# Fetching all the Nest for multivalue network address\nsteps = ipv4PrefixPool.NetworkAddress.Steps\nixNetwork.info(steps)\n\n# Setting values for different Nest multivalue\nsteps[1].Enabled = \"True\"\nsteps[1].Step = \"0.0.0.4\"\n\nsteps[0].Enabled = \"True\"\nsteps[0].Step = \"1.0.0.4\"\n"
            },
            {
                "name": "ngpf_device_ids.py",
                "content": "\"\"\"Demonstrates some best practices for specifying device ids when executing ngpf operations\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# create a b2b ngpf scenario\nvport_1 = ixnetwork.Vport.add().add().add()\nprint(vport_1)\nvport_2 = ixnetwork.Vport.add()\ntopologies = ixnetwork.Topology.add(Vports=vport_1).add(Vports=vport_2)\nipv4_1 = topologies[0].DeviceGroup.add().Ethernet.add().Ipv4.add()\nigmp_host = ipv4_1.IgmpHost.add()\nipv4_2 = topologies[1].DeviceGroup.add().Ethernet.add().Ipv4.add()\nigmp_querier = ipv4_2.IgmpQuerier.add()\n\n# set the port step on the address\naddress = ipv4_1.Address\nprint(address.Steps)\naddress.Steps.Step = \"1.1.1.1\"\nassert address.Steps.Step == \"1.1.1.1\"\n\n# get device ids for two specific ip addresses\nipv4_device_ids = ipv4_1.get_device_ids(\n    Address=\"^(%s|%s)\" % (ipv4_1.Address.Values[6], ipv4_1.Address.Values[24])\n)\nassert len(ipv4_device_ids) == 2\n\n# get device ids on two specific ports\nport_device_ids = ipv4_1.get_device_ids(\n    PortNames=\"^(%s|%s)$\" % (vport_1[0].Name, vport_1[2].Name)\n)\nassert len(port_device_ids) == 20\n\n# get device ids for igmp v2 hosts on a specific port\nv2_device_ids = igmp_host.get_device_ids(\n    PortNames=\"(?i)^%s$\" % (vport_1[1].Name), VersionType=\"(?i)version2\"\n)\nassert len(v2_device_ids) == 10\n\n# stop all devices\nipv4_1.Stop()\n\n# start only a few devices\nipv4_1.Start(ipv4_device_ids)\n\n# leave\nigmp_host.IgmpMcastIPv4GroupList.IgmpLeaveGroup(\"1-4;6\")\n\n# issue a join on only a few devices\nigmp_host.IgmpMcastIPv4GroupList.Join(v2_device_ids)\n"
            },
            {
                "name": "ngpf_ipv4.py",
                "content": "\"\"\"Demonstrates adding ipv4 devices\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\n\nipv4 = (\n    session_assistant.Ixnetwork.Topology.add()\n    .DeviceGroup.add()\n    .Ethernet.add()\n    .Ipv4.add()\n)\nprint(ipv4)\n"
            },
            {
                "name": "object_from_obj_ref.py",
                "content": "\"\"\"Demonstrates how to get an object given an href\n\nThe TestPlatform.Sessions class has a helper method that assists in returning an object given a valid href\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\n# create a test tool session\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\nvport = ixnetwork.Vport.add()\n\n# the following code is an attempt to get the object that the vport is connected to\n# in this case the href that is returned from the .ConnectedTo property is null so the object returned is None\n# if the vport was connected to an actual hardware port a valid /availableHardware/chassis/card/port object reference\n# would be returned from the Vport.ConnectedTo property\n# this reference is then used to get an actual object\nhardware_port = session_assistant.Session.GetObjectFromHref(vport.ConnectedTo)\nassert hardware_port is None\n"
            },
            {
                "name": "patternType_in_multivalue.py",
                "content": "\"\"\"\nDemonstrates how pattern type property can be used for info or to modify exsisting multivalue instance\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\n\nixnetwork = session_assistant.Ixnetwork\n\n# adding ipv4 stack\nipv4 = ixnetwork.Topology.add().DeviceGroup.add().Ethernet.add().Ipv4.add()\n\n# fetching ipv4 address multivalue object\naddress = ipv4.Address\n\n# fetching Pattern type for Multivalue instance\nixnetwork.info(address.PatternType)\n\n# modifying multivalue based on pattern type\nif address.PatternType == \"Increment\":\n    address.Increment(start_value=\"1.1.1.1\", step_value=\"1.0.0.0\")\n\nelif address.PatternType == \"Decrement\":\n    address.Decrement(start_value=\"100.1.1.1\", step_value=\"1.0.0.0\")\n"
            },
            {
                "name": "resource_manager.py",
                "content": "\"\"\"Demonstrates some best practices for using resource manager to import and export the configuration as json\n\n\"\"\"\n\nimport json\nfrom ixnetwork_restpy import SessionAssistant, Files\n\n\n# create a test tool session\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# create a configuration fragment of two virtual ports\nvports = [\n    {\"xpath\": \"/vport[1]\", \"name\": \"vport 1\"},\n    {\"xpath\": \"/vport[2]\", \"name\": \"vport 2\"},\n]\n\n# import the configuration fragment as a string\nixnetwork.ResourceManager.ImportConfig(json.dumps(vports), True)\nassert len(ixnetwork.Vport.find()) == 2\n\n# export the entire configuration as a string\nconfig = ixnetwork.ResourceManager.ExportConfig(\n    [\"/descendant-or-self::*\"], False, \"json\"\n)\n\n# import the entire configuration as a string\nixnetwork.ResourceManager.ImportConfig(config, True)\nassert len(ixnetwork.Vport.find()) == 2\n\n# export the entire configuration as a file\nixnetwork.ResourceManager.ExportConfigFile(\n    [\"/descendant-or-self::*\"], False, \"json\", Files(\"two_vports.json\")\n)\n\n# import then entire configuration from a file\nixnetwork.ResourceManager.ImportConfigFile(Files(\"two_vports.json\"), True)\nassert len(ixnetwork.Vport.find()) == 2\n"
            }
        ]
    },
    {
        "name": "Classic",
        "children": [
            {
                "name": "classic_bgp.py",
                "content": "\"\"\"Demonstrates adding a bgp neighbor range to a virtual port.\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# add a virtual port and get the interface object\nvport = ixnetwork.Vport.add(Name=\"Test Port 1\")\n\n# add an interface\ninterface = vport.Interface.add(Enabled=True)\nipv4 = interface.Ipv4.add(Ip=\"1.1.1.1\", Gateway=\"1.1.2.1\")\n\n# enable bgp\nbgp = vport.Protocols.find().Bgp\nbgp.Enabled = True\n\n# add a bgp neighbor range\nneighbor_range = bgp.NeighborRange.add(\n    Interfaces=interface, Enabled=True, EnableBgpId=True\n)\n\n# verify the neighbor range has been added on the server\nassert len(neighbor_range.find()) == 1\n"
            },
            {
                "name": "classic_interfaces.py",
                "content": "\"\"\"Demonstrates adding interfaces to virtual ports.\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# add a virtual port and get the interface object\ninterfaces = ixnetwork.Vport.add(Name=\"Test Port 1\").Interface\n\n# add 10 interfaces\nfor i in range(1, 11):\n    interfaces.add(Description=\"Interface Demo %s\" % i, Enabled=True)\n\n# verify they have been added on the server\nassert len(interfaces.find()) == 10\n"
            }
        ]
    },
    {
        "name": "Files",
        "children": [
            {
                "name": "file_transfer.py",
                "content": "\"\"\"Demonstrates how to upload and download files to a remote server.\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, Files\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# add 4 vport objects\nixnetwork.Vport.add().add().add().add()\n\n# save the configuration on the server\nixnetwork.SaveConfig(Files(\"sample.ixncfg\"))\n\n# get a list of remote files\nprint(session_assistant.Session.GetFileList())\n\n# download the remote saved configuration as some other local file\nsession_assistant.Session.DownloadFile(\"sample.ixncfg\", \"local.ixncfg\")\n\n# upload the local file\nprint(session_assistant.Session.UploadFile(\"local.ixncfg\"))\n\n# load the remote local configuration\nprint(ixnetwork.LoadConfig(Files(\"local.ixncfg\")))\n\n# verify that the vport objects exist\nassert len(ixnetwork.Vport.find()) == 4\n"
            },
            {
                "name": "get_file_info.py",
                "content": "\"\"\"\nDemonstrates use the filter option to get a custom set of files with its details\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n# create a test tool session\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    RestPort=11009,\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_ALL,\n    ClearConfig=False,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# get custom set of files from the server by applying the filter, e.g. here we are querying for only config files\nfile_list = ixnetwork.parent.GetFileList(filter=\"*.ixncfg|*.json\")\n# ensure we got files key in our response\nif file_list.get(\"files\") is not None:\n    # print the no of diagnostic files received\n    print(len(file_list[\"files\"]))\n    # loop through each of file to get file information\n    for file in file_list[\"files\"]:\n        # print some file information\n        print(file[\"name\"], file[\"length\"], file[\"createdUnixTime\"])\nelse:\n    raise Exception(\"Files not present in the server response\")\n"
            },
            {
                "name": "save_load_config.py",
                "content": "\"\"\"Demonstrates file handling.\n\nThe Files object determines how file content is uploaded.\nPrior to an operation if local_file=True is specified the content will be pushed to the server \nif the content exists locally.\nIf the file does not exist locally an empty file using only the file name will be created on the server. \n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, Files\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# add 4 vport objects\nixnetwork.Vport.add().add().add().add()\n\n# save the configuration on the server\nixnetwork.SaveConfig(Files(\"sample.ixncfg\"))\n\n# create an empty configuration\nixnetwork.NewConfig()\nassert len(ixnetwork.Vport.find()) == 0\n\n# load the saved configuration\nixnetwork.LoadConfig(Files(\"sample.ixncfg\"))\n\n# verify that the vport objects exist\nassert len(ixnetwork.Vport.find()) == 4\n"
            }
        ]
    },
    {
        "name": "Logging",
        "children": [
            {
                "name": "collect_logs.py",
                "content": "\"\"\"Demonstrates collecting diagnostic logs \n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, Files\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\nixnetwork.CollectLogs(Arg1=Files(\"diagnostic_logs\"), Arg2=\"currentInstance\")\nsession_assistant.Session.DownloadFile(\"diagnostic_logs.zip\")\n"
            },
            {
                "name": "restapi_logging.py",
                "content": "\"\"\"The following demonstrates the logging features of this package\n\nThe different trace options are meant to expose the details of the request and response messages. \nThe default output is to sys.stdout\nTo output to a log file, use the log_file_name param\nThe trace level can be specified in the SessionAssistant constructor and subsequently modified using the TestPlatform.Trace property.\nThe default log level is SessionAssistant.LOGLEVEL_NONE which has a logging level of CRITICAL\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, TestPlatform\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\ntest_platform = session_assistant.TestPlatform\nixnetwork = session_assistant.Ixnetwork\n\n# warn level messages logged\ntest_platform.Trace = TestPlatform.TRACE_WARNING\ntest_platform.warn(\"warn message\")\n\n# info level messages logged\ntest_platform.Trace = TestPlatform.TRACE_INFO\ntest_platform.info(\"info message\")\n\n# debug level messages showing only request\ntest_platform.Trace = TestPlatform.TRACE_REQUEST\nixnetwork.Vport.add()\n\n# debug level messages showing request and response truncated\ntest_platform.Trace = TestPlatform.TRACE_REQUEST_RESPONSE\nixnetwork.Vport.add()\n\n# debug level messages showing entire request and response\ntest_platform.Trace = TestPlatform.TRACE_ALL\nixnetwork.Vport.add()\n\n# turn logging off\ntest_platform.Trace = TestPlatform.TRACE_NONE\ntest_platform.warn(\"warn message\")\ntest_platform.info(\"info message\")\nixnetwork.Vport.add()\n"
            }
        ]
    },
    {
        "name": "Ports",
        "children": [
            {
                "name": "assign_ports.py",
                "content": "\"\"\"Demonstrates the best practice for connecting vport(s) to hardware test ports.\n\nAssignPorts is currently the optimal method for connecting hardware test ports to vport(s).\n\nThe AssignPorts method on the test platform does the following:\n\t- adds chassis to /availableHardware using Arg1\n\t- creates abstract ports if the abstract port list (Arg3) cannot meet the number of Arg1 test ports\n\t- clears ownership of test ports if Arg4 is True\n\t- waits until port statistic view for all test ports are ready\n\t- returns a list of abstract test ports that have not been connected to test ports\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# setup test ports and virtual ports\nchassis_ip = \"10.36.74.26\"\ntest_ports = [\n    dict(Arg1=chassis_ip, Arg2=2, Arg3=13),\n    dict(Arg1=chassis_ip, Arg2=2, Arg3=14),\n]\nvirtual_ports = ixnetwork.Vport.add().add()\n\nconnected_ports = ixnetwork.AssignPorts(test_ports, [], virtual_ports, True)\n"
            },
            {
                "name": "clear_ownership.py",
                "content": "\"\"\"Demonstrates an approach for clearing ownership on vports that are connected \nby using the Vport.ConnectedTo reference and obtaining the Port object which has the ClearOwnership method\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# add a chassis\nchassis = ixnetwork.AvailableHardware.Chassis.add(Hostname=\"10.36.74.17\")\n\n# add abstract ports and connect them to chassis ports\ncard = chassis.Card.find(CardId=1)\nfor port in card.Port.find():\n    ixnetwork.Vport.add(ConnectedTo=port)\n\n# clear the ownership on the port using a reference returned by the Vport.ConnectedTo property\nfor vport in ixnetwork.Vport.find():\n    port = session_assistant.Session.GetObjectFromHref(vport.ConnectedTo)\n    if port is not None:\n        port.ClearOwnership()\n"
            },
            {
                "name": "port_lldp_info.py",
                "content": "\"\"\"\nThe test basically explain how we can get LLDP information from chassis and port level\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\nimport time\n\n\ndef main():\n    chassis_ip = \"10.39.49.58\"\n    # creating a test tool session\n    session_assistant = SessionAssistant(\n        IpAddress=\"10.39.39.205\",\n        RestPort=11009,\n        LogLevel=SessionAssistant.LOGLEVEL_INFO,\n        ClearConfig=True,\n    )\n    ixnetwork = session_assistant.Ixnetwork\n    ixnetwork.info(\"Session created\")\n\n    ixnetwork.info(\"Adding chassis/location\")\n    ixnetwork.Locations.add(Hostname=chassis_ip)\n\n    # waiting for the State of chassis to be 'Ready'\n    while ixnetwork.Locations.find()[0].State != \"ready\":\n        time.sleep(1)\n\n    # LLDP properties from chassis/location\n    locations = ixnetwork.Locations.find()\n    obj = locations[0]\n    print(\"\\n\\nLLDP Peer Info learned from \" + chassis_ip + \".......\\n\")\n    # Filter attributes\n    attributes = [attr for attr in dir(obj) if attr.startswith(\"Peer\")]\n    print_data_table(obj, attributes)\n\n    # LLDP info from all ports\n    ports = locations[0].Ports.find()\n    for port in ports:\n        obj = port\n        print(\"\\n\\nLLDP Peer Info learned from \" + port.Location + \" .......\\n\")\n        # Filter attributes\n        attributes = [attr for attr in dir(obj) if attr.startswith(\"Peer\")]\n        print_data_table(obj, attributes)\n\n\ndef print_data_table(obj, attributes):\n    # Extract attribute values\n    data = {attr: getattr(obj, attr, None) for attr in attributes}\n    # Determine column widths\n    max_attr_width = max(len(attr) for attr in data.keys())\n    max_value_width = max(len(str(value)) for value in data.values())\n    # Print table headers\n    header = f\"{'Attribute'.ljust(max_attr_width)} | {'Value'.ljust(max_value_width)}\"\n    separator = f\"{'-' * max_attr_width}-+-{'-' * max_value_width}\"\n    print(header)\n    print(separator)\n    # Print table rows\n    for attr, value in data.items():\n        print(f\"{attr.ljust(max_attr_width)} | {str(value).ljust(max_value_width)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
            },
            {
                "name": "tap_settings.py",
                "content": "\"\"\"\nThe test explains how we can configure tap settings for different ports\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant, BatchUpdate\n\n\n# create a test tool session\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    RestPort=11009,\n    LogLevel=SessionAssistant.LOGLEVEL_ALL,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\nprint(ixnetwork)\n\n# Adding ports for which we want to update port setting\nport_map = session_assistant.PortMapAssistant()\nport_map.Map(Location=\"10.39.49.57;2;3\", Name=\"Port 1\")\nport_map.Map(Location=\"10.39.49.57;2;4\", Name=\"Port 2\")\nport_map.Map(Location=\"10.39.51.127;9;1\", Name=\"Port 3\")\nport_map.Map(Location=\"10.39.51.127;9;2\", Name=\"Port 4\")\n\nport_map.Connect(ForceOwnership=True, HostReadyTimeout=20, IgnoreLinkUp=True)\n\n# fetch tap settings for all the ports\nixnetwork.GetTapSettings()\n\n# get tap setting for each vport\nvport = ixnetwork.Vport.find()\ntapSet = vport.TapSettings.find()\n# using batch update to update tap settings value\nwith BatchUpdate(ixnetwork):\n    for ts in tapSet:\n        params = ts.Parameter.find()\n        man = None\n        model = None\n        paramToSet = None\n        for param in params:\n            if param.Name == \"Manufacturer\":\n                man = param.CurrentValue\n            elif param.Name == \"Model\":\n                model = param.CurrentValue\n            elif param.Name == \"TxPreTapControl\":\n                paramToSet = param\n        # Please update the conditions and parameters according to test criteria\n        if (\n            man == \"FINISAR CORP.\"\n            and model == \"FTLX8571D3BCL\"\n            and paramToSet is not None\n        ):\n            paramToSet.CurrentValue = 7\n\n# setting tap settings across all ports of different chassis\nixnetwork.SetTapSettings()\n"
            },
            {
                "name": "L1config",
                "children": [
                    {
                        "name": "l1_config_pcs_error_generation.py",
                        "content": "\"\"\"\nl1_config_pcs_error_generation.py:\n\n    - Connect to the API server\n    - In this test, do the following:\n        - Add two real ports \n        - Add two vports\n        - Assign two real ports in to vports\n        - Find the pcsErrorGeneration from the l1Config\n        - Update some attributes of pcsErrorGeneration\n        - Verify the value of the attributes\n     \nSupports IxNetwork API servers:\n   - Windows, Windows Connection Mgr and Linux\n   \nRequirements:\n   - Minimum IxNetwork 9.30 Update 1\n   - Python 2.7 and 3+\n   - pip install requests\n   - pip install ixnetwork_restpy (minimum version 1.1.9)\n   \nRestPy Doc:\n    https://openixia.github.io/ixnetwork_restpy/#/overview\n\nUsage:\n   - Enter: python <script>\n   \n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"<chassis-ip>\",\n    RestPort=\"<rest-port>\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\n\nixnetwork = session_assistant.Ixnetwork\n\n# mapping the ports\nport_map = session_assistant.PortMapAssistant()\nport_map.Map(Location=\"<chassis-ip>;<card>;<port>\", Name=\"Port 1\")\nport_map.Map(Location=\"<chassis-ip>;<card>;<port>\", Name=\"Port 2\")\n\n# using the map connect test port locations and vports\nport_map.Connect(ForceOwnership=True, HostReadyTimeout=20, LinkUpTimeout=60)\nvport1 = ixnetwork.Vport.find(Name=\"Port 1\")\nvport2 = ixnetwork.Vport.find(Name=\"Port 2\")\n\n# PCS Error Generation configuration\nv1_pcsErrorGeneration = vport1.L1Config.PcsErrorGeneration\nv1_pcsErrorGeneration.update(PeriodType=\"laneMarkersAndPayload\")\nv1_pcsErrorGeneration.update(ErrorBitsHexLaneMarkers=\"1122334455DDEEFF\")\nvport1.StartPcsErrorGeneration()\n"
                    },
                    {
                        "name": "l1_config_tx_lane_and_skew.py",
                        "content": "\"\"\"\nl1_config_aresone_800g_tx_lane_and_skew_checking.py:\n\n    - Connect to the API server\n    - In this test, do the following:\n        - Add two real ports of AresOne 800G\n        - Add two vports\n        - Assign two the ports in to vports\n        - Find the AresOneEightHundredGigLanQddC from the l1Config\n        - Update TxLane and Skew attributes of AresOneEightHundredGigLanQddC\n        - Verify the value of the attributes\n     \nSupports IxNetwork API servers:\n   - Windows, Windows Connection Mgr and Linux\n   \nRequirements:\n   - Minimum IxNetwork 9.30 Update 1\n   - Python 2.7 and 3+\n   - pip install requests\n   - pip install ixnetwork_restpy (minimum version 1.1.9)\n   \nRestPy Doc:\n    https://openixia.github.io/ixnetwork_restpy/#/overview\n\nUsage:\n   - Enter: python <script>\n   \n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"<chassis-ip>\",\n    RestPort=\"<rest-port>\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\n\nixnetwork = session_assistant.Ixnetwork\n\n# mapping the ports. Here we have used AresOne-800G for reference\nport_map = session_assistant.PortMapAssistant()\nport_map.Map(Location=\"<chassis-ip>;<card>;<port>\", Name=\"Port 1\")\nport_map.Map(Location=\"<chassis-ip>;<card>;<port>\", Name=\"Port 2\")\n\n# using the map connect test port locations and vports\nport_map.Connect(ForceOwnership=True, HostReadyTimeout=20, LinkUpTimeout=60)\nvport1 = ixnetwork.Vport.find(Name=\"Port 1\")\nvport2 = ixnetwork.Vport.find(Name=\"Port 2\")\n\n# Tx Lane and skew\nv1_txLane = vport1.L1Config.AresOneEightHundredGigLanQddC.TxLane\nprint(v1_txLane)\nv1_txLane.update(IsSkewSynchronized=\"true\")\n"
                    }
                ]
            }
        ]
    },
    {
        "name": "Protocols",
        "children": [
            {
                "name": "bgp_learned_info.py",
                "content": "\"\"\"\nThis sample actually demonstrates how call and see the learned information of a protocol.\nThe sample will be almost identical for rest of the protocols as well\nIn this test its assumed that bgp session is configured properly and is up and running\nThis test fetches the bgpv4 peer interface and calls the operation to get all learned info\nAfter that it showcases from where we can get the learned info information for bgp.\n\nSupports IxNetwork API servers:\n   - Windows, Windows Connection Mgr and Linux\n\nRequirements:\n   - Minimum IxNetwork 8.50\n   - Python 2.7 and 3+\n\nRestPy Doc:\n    https://openixia.github.io/ixnetwork_restpy/#/overview\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n# connecting to an existing ixn session , note the clear config is false.\nsession_assistant = SessionAssistant(\n    IpAddress=\"localhost\",\n    RestPort=11009,\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_ALL,\n    ClearConfig=False,\n)\n\nixn = session_assistant.Ixnetwork\n\n# finding the bgpv4 peer according to our need\nbgp = (\n    ixn.Topology.find()\n    .DeviceGroup.find()\n    .Ethernet.find()\n    .Ipv4.find()\n    .BgpIpv4Peer.find()\n)\n\n# calling the get all learned info operation\n# note here we have showcased a simple call that fetches learned info of all bgp sessions\n# if a particular session is required we can pass a list of session indices\n# eg: bgp.GetAllLearnedInfo([1,5,9])\nbgp.GetAllLearnedInfo()\n\n# showcases from where we can retrieve the fetched learned info\nlearned_info_table = bgp.LearnedInfo.find().Table.find()\nprint(learned_info_table)\n"
            },
            {
                "name": "ospf.py",
                "content": "\"\"\"Demonstrates creating ospfv2 devices \n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\ndg = ixnetwork.Topology.add(Vports=ixnetwork.Vport.add()).DeviceGroup.add(\n    Name=\"Dg West\"\n)\nospf1 = dg.Ethernet.add().Ipv4.add(Name=\"Ipv4 West\").Ospfv2.add()\ndg.NetworkGroup.add(Multiplier=20).Ipv4PrefixPools.add()\n\nospf2 = (\n    ixnetwork.Topology.add(Vports=ixnetwork.Vport.add())\n    .DeviceGroup.add(Name=\"Dg East\")\n    .Ethernet.add()\n    .Ipv4.add(Name=\"Ipv4 East\")\n    .Ospfv2.add()\n)\n"
            },
            {
                "name": "tlvprofile.py",
                "content": "\"\"\"Demonstrates creating and copying over tlv templates into a tlv profile\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession = SessionAssistant(\n    \"127.0.0.1\", LogLevel=SessionAssistant.LOGLEVEL_INFO, ClearConfig=True\n)\nixnetwork = session.Ixnetwork\n\n# create a custom tlv template\ngeneric_tlv = (\n    ixnetwork.Globals.Topology.Dhcpv6client.TlvEditor.find()\n    .Template.add(Name=\"generic\")\n    .Tlv.add(Name=\"generic\")\n)\ngeneric_tlv.Type.update(Name=\"type\").Object.add(Name=\"type\").Field.add(\n    Name=\"type\"\n).Value.Single(\"10\")\ngeneric_tlv.Length.update(Name=\"length\").Value.Single(\"11\")\ngeneric_tlv.Value.update(Name=\"value\").Object.add(Name=\"value\").Field.add(\n    Name=\"value\"\n).Value.Single(\"12\")\nixnetwork.info(generic_tlv)\n\n# get a default tlv template\noption_request = (\n    ixnetwork.Globals.Topology.Dhcpv6client.TlvEditor.find()\n    .Defaults.find()\n    .Template.find()\n    .Tlv.find(Name=\"Option Request\")\n)\nixnetwork.info(option_request)\n\n# get the dhcpv6client tlv profile\ntlv_profile = (\n    ixnetwork.Topology.add()\n    .DeviceGroup.add()\n    .Ethernet.add()\n    .Dhcpv6client.add()\n    .TlvProfile.find()\n)\nixnetwork.info(tlv_profile)\n\n# copy tlv templates into the dhcpv6client tlv profile\ngeneric_tlv = ixnetwork.parent.GetObjectFromHref(tlv_profile.CopyTlv(generic_tlv))\noption_request = ixnetwork.parent.GetObjectFromHref(tlv_profile.CopyTlv(option_request))\n\n# print option request tlv sub options\nfor sub_option in option_request.Value.Object.find().Field.find():\n    ixnetwork.info(sub_option)\n"
            }
        ]
    },
    {
        "name": "Quicktests",
        "children": [
            {
                "name": "rfc2544back2back.py",
                "content": "\"\"\"Demonstrates creating ospfv2 devices \n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\nipv41 = (\n    ixnetwork.Topology.add(Vports=ixnetwork.Vport.add())\n    .DeviceGroup.add(Name=\"Dg West\")\n    .Ethernet.add()\n    .Ipv4.add(Name=\"Ipv4 West\")\n)\n\nipv42 = (\n    ixnetwork.Topology.add(Vports=ixnetwork.Vport.add())\n    .DeviceGroup.add(Name=\"Dg East\")\n    .Ethernet.add()\n    .Ipv4.add(Name=\"Ipv4 East\")\n)\n\ntraffic = ixnetwork.Traffic.TrafficItem.add(Name=\"West -> East\", TrafficType=\"ipv4\")\ntraffic.EndpointSet.add(Sources=ipv41, Destinations=ipv42)\n\ntest_details = ixnetwork.Timeline.CreateTest(Arg2=\"rfc2544back2back\", Arg3=\"none\")\nprint(test_details)\ntest = ixnetwork.parent.GetObjectFromHref(test_details[\"arg1\"])\ntest.TrafficItemIds = traffic\n"
            }
        ]
    },
    {
        "name": "Sessions",
        "children": [
            {
                "name": "connection_manager.py",
                "content": "\"\"\" Demonstrates IxNetwork Connection Manager session management\n\"\"\"\n\nfrom ixnetwork_restpy.testplatform.testplatform import TestPlatform\n\n\n# setup the connection information for a connection manager test platform\ntest_platform = TestPlatform(\n    \"10.113.9.116\", rest_port=443, platform=\"connection_manager\"\n)\ntest_platform.Trace = \"request_response\"\n\n# get a list of sessions\nfor session in test_platform.Sessions.find():\n    print(session)\n\n# add a session and remove the session\nsessions = test_platform.Sessions.add()\nassert len(sessions) == 1\nprint(sessions)\nsessions.remove()\n\n# get an invalid session\nsessions = test_platform.Sessions.find(Id=6)\nassert len(sessions) == 0\n\n# get a valid session, start it and remove it when finished\n# use the state to determine if it can be stopped\nsessions = test_platform.Sessions.find(Id=8022)\nassert len(sessions) == 1\nif sessions.State == \"STOPPED\":\n    sessions.Start()\n    sessions.remove()\n"
            },
            {
                "name": "linux_sessions.py",
                "content": "\"\"\" Demonstrates IxNetwork Linux API Server session management\n\"\"\"\n\nfrom ixnetwork_restpy.testplatform.testplatform import TestPlatform\n\n\n# setup the connection information for a windows gui test platform that has a default session of 1\n# platform='linux' forces the scheme to https\n# if the default platform='windows' is used a ConnectionError will be raised\n# as the Linux API Server does not redirect but closes the connection\ntest_platform = TestPlatform(\"10.36.82.185\")\nassert test_platform.Platform == \"linux\"\ntest_platform.Trace = \"request_response\"\n\n# authenticate with username and password\ntest_platform.Authenticate(\"admin\", \"admin\")\napi_key = test_platform.ApiKey\n\n# if username/password is not acceptable to the client due to the unencrypted password\n# an api key can be specified instead\n# the api key can be retrieved from the linux api server user settings and provided\n# to the TestPlatform.ApiKey property which will be used in subsequent server requests\ntest_platform.ApiKey = api_key\n\n# get a list of sessions\nfor session in test_platform.Sessions.find():\n    print(session)\n\n# add a session\nsessions = test_platform.Sessions.add(ApplicationType=\"ixnrest\")\nsession_id = sessions.Id\nprint(sessions)\n\n# change the name of a session\nsession_name = \"new session name\"\nsessions.Name = session_name\nassert sessions.Name == session_name\nprint(sessions)\n\n# find by session name\nsessions = test_platform.Sessions.find(Name=session_name)\nassert len(sessions) == 1\n\n# remove the session\nsessions.remove()\nassert len(sessions) == 0\n\n# attempt to get the removed session\nsessions = test_platform.Sessions.find(session_id)\nassert len(sessions) == 0\n"
            },
            {
                "name": "quicktest.py",
                "content": "\"\"\" Demonstrates how to create a Linux API Server QuickTest Web session\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\n# create a linux api server quicktest session\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    ApplicationType=SessionAssistant.APP_TYPE_QUICKTEST,\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nprint(session_assistant.Session)\nsession_assistant.Session.remove()\n\n# create a linux api server ixnetwork session\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    ApplicationType=SessionAssistant.APP_TYPE_IXNETWORK,\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nprint(session_assistant.Session)\nsession_assistant.Session.remove()\n"
            },
            {
                "name": "windows_sessions.py",
                "content": "\"\"\" Demonstrates standalone IxNetwork Windows GUI session management\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\ntest_platform = session_assistant.TestPlatform\n\n# get a list of sessions\nfor session in test_platform.Sessions.find():\n    print(session)\n\n# add a session and remove the session\nsessions = test_platform.Sessions.add()\nassert len(sessions) == 1\nprint(sessions)\nsessions.remove()\n\n# get an invalid session\nsessions = test_platform.Sessions.find(Id=6)\nassert len(sessions) == 0\n\n# get a valid session\nsessions = test_platform.Sessions.find(Id=1)\nassert len(sessions) == 1\n"
            }
        ]
    },
    {
        "name": "Statistics",
        "children": [
            {
                "name": "csv_logging.py",
                "content": "\"\"\" Sample that demonstrates how to enable CSV logging for a view\nand download the resulting CSV log file once it is disabled.\n\nThe sample operates under the following assumptions:\n    - it is for an established IxNetwork GUI session\n    - traffic is running\n    - there is a Port Statistics view\n\n\"\"\"\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# assumes that the view exists and it sets up csv logging for the view\nview = ixnetwork.Statistics.View.find(Caption=\"Port Statistics\")\nview.update(EnableCsvLogging=True)\n\n# this builds the full path of the csv file on the server\nremote_csv_filename = \"%s/%s\" % (ixnetwork.Statistics.CsvFilePath, view.CsvFileName)\n\n# setup a local path\nlocal_csv_filename = \"c:/temp/%s\" % view.CsvFileName\n\n# in order to download the csv log file the csv logging must be disabled\n# otherwise a sharing violation from the server will be returned\nixnetwork.Statistics.EnableCsvLogging = False\nsessions.DownloadFile(remote_csv_filename, local_csv_filename)\n"
            },
            {
                "name": "csv_snapshot.py",
                "content": "\"\"\" Sample that demonstrates how to take a CSV snapshot of a statistics view\n\nThe sample operates under the following assumptions:\n    - it is for an established IxNetwork GUI session\n    - traffic is running\n    - there is a Flow Statistics view\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\nimport os\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n)\nixnetwork = session_assistant.Ixnetwork\nsession = session_assistant.Session\nfile_name = \"StatisticsSnapshot\"\n\nixnetwork.info(\n    \"\"\"\n1) setup the csv snapshot parameters\n2) ensure the CsvName DOES NOT end with a .csv extension\n\tthe IxNetwork server will add a .csv extension to the final csv filename\n3) ensure the CsvLocation is a path on the IxNetwork server that the IxNetwork server has access to, \n\tthe best practice is to use the Ixnetwork.Statistics.CsvFilePath location\n\"\"\"\n)\nstatistics = ixnetwork.Statistics\ncsvsnapshot = statistics.CsvSnapshot\ncsvsnapshot.update(\n    CsvName=file_name,\n    CsvLocation=statistics.CsvFilePath,\n    SnapshotViewCsvGenerationMode=\"overwriteCSVFile\",\n    SnapshotViewContents=\"allPages\",\n    Views=statistics.View.find(Caption=\"^Port Statistics$\"),\n)\n\nixnetwork.info(csvsnapshot)\n\nixnetwork.info(\n    \"\"\"\n4) take the csv snapshot\n\"\"\"\n)\ncsvsnapshot.TakeCsvSnapshot()\n\nixnetwork.info(\n    \"\"\"\n5) the csv snapshot file is on the IxNetwork server and can be downloaded\n\tThe csv snapshot file name is the CsvLocation and CsvName and .csv extension\n    The snapshot API will always add a .csv extension\n\"\"\"\n)\nfile_name = file_name + \".csv\"\n\nremote_filename = os.path.normpath(os.path.join(csvsnapshot.CsvLocation, file_name))\nlocal_filename = os.path.normpath(os.path.join(\"c:/temp\", file_name))\nsession.DownloadFile(remote_filename, local_filename)\n\nwith open(local_filename, \"r\") as fid:\n    print(fid.read())\n"
            },
            {
                "name": "drill_down.py",
                "content": "\"\"\"Demonstrates drilling down on an already established statistics view.\nThis sample requires a running ixnetwork instance that has traffic being transmitted.\n\"\"\"\n\nfrom time import sleep\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# get the view you want to drill down on\ncaption = \"Traffic Item Statistics\"\nview = ixnetwork.Statistics.View.find(Caption=caption)\nassert len(view) == 1\n\n# get the drill down node for the view\ndrill_down = view.DrillDown.find()\n\n# prior to getting the drill down options the target row index must be set\n# the target row index is the 0 based index of the row that you are interested in drilling down into\ndrill_down.TargetRowIndex = 0\n\n# print the drill down options for the view\n# drill down options are dynamic and are based on tracking options selected during traffic item creation\nfor drill_down_filter in drill_down.AvailableTargetRowFilters:\n    print(drill_down_filter)\nif len(drill_down.AvailableTargetRowFilters) > 0:\n    drill_down.TargetRowFilter = drill_down.AvailableTargetRowFilters[0]\nfor drill_down_option in drill_down.AvailableDrillDownOptions:\n    print(drill_down_option)\ndrill_down.TargetDrillDownOption = drill_down.AvailableDrillDownOptions[1]\n\n# perform the drill down operation\ndrill_down.DoDrillDown()\n\n# the drill down operation populates the read only 'User Defined Statistics' view\n# get the resulting drill down view\nuser_defined_statistics = ixnetwork.Statistics.View.find(\n    Caption=\"User Defined Statistics\"\n)\n\n# wait for data to become available\nattempts = 0\nwhile user_defined_statistics.Data.IsReady is False and attempts < 10:\n    sleep(1)\n    attempts += 1\n\n# print the column headers\nprint(\" \".join(user_defined_statistics.Data.ColumnCaptions))\n\n# print the ingress and egress rows\nfor ingress_egress_rows in user_defined_statistics.Data.PageValues:\n    for row in ingress_egress_rows:\n        print(\" \".join(row))\n"
            },
            {
                "name": "traffic_flow.py",
                "content": "\"\"\"Demonstrates creating a custom traffic flow statistics view\nThis sample requires a running ixnetwork instance that has traffic being transmitted.\nIt uses all possible port filters, traffic item filters and tracking filters when creating the view.\nIt enables all possible statistics.\nThe last step prior to getting data should be to enable the view.\n\"\"\"\n\nfrom time import sleep\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n\n# remove the view if it already exists\ncaption = \"Custom Traffic Flow View\"\nview = ixnetwork.Statistics.View.find(Caption=caption)\nif len(view) == 1:\n    view.remove()\n\n# create the view\nview = ixnetwork.Statistics.View.add(\n    Caption=caption, Type=\"layer23TrafficFlow\", Visible=True\n)\n\n# set filters\ntraffic_flow_filter = view.Layer23TrafficFlowFilter.find()\ntraffic_flow_filter.PortFilterIds = view.AvailablePortFilter.find()\ntraffic_flow_filter.TrafficItemFilterIds = view.AvailableTrafficItemFilter.find()\nfor tracking_filter in view.AvailableTrackingFilter.find():\n    traffic_flow_filter.EnumerationFilter.add(\n        SortDirection=\"ascending\", TrackingFilterId=tracking_filter\n    )\n\n# enable statistics\nfor statistic in view.Statistic.find():\n    statistic.Enabled = True\n\n# enable the view\nview.Enabled = True\n\n# wait for data to become available\nattempts = 0\nwhile view.Data.IsReady is False and attempts < 10:\n    sleep(1)\n    attempts += 1\n\n# print the column headers\nprint(\" \".join(view.Data.ColumnCaptions))\n\n# print the ingress and egress rows\nfor ingress_egress_rows in view.Data.PageValues:\n    for row in ingress_egress_rows:\n        print(\" \".join(row))\n"
            },
            {
                "name": "Custom_view",
                "children": [
                    {
                        "name": "port_custom_view.py",
                        "content": "\"\"\"\nCreates a port custom view\nThis sample requires a running ixnetwork instance that has ports in up state.\nIt uses all possible port filters and statistics when creating the view.\nThe last step prior to getting data should be to enable the view.\n\nSupports IxNetwork API servers:\n   - Windows, Windows Connection Mgr and Linux\n\nRequirements:\n   - Minimum IxNetwork 9.30\n   - Python 2.7 and 3+\n   - pip install requests\n   - pip install ixnetwork_restpy (minimum version 1.1.8)\n\"\"\"\n\nfrom time import sleep\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=False,\n)\nixnetwork = session_assistant.Ixnetwork\n\n\n# remove the view if it already exists\ncaption = \"Port Custom View\"\nview = ixnetwork.Statistics.View.find(Caption=caption)\nif len(view) == 1:\n    view.remove()\n\n# create the view\nview = ixnetwork.Statistics.View.add(\n    Caption=caption, Type=\"layer23ProtocolPort\", Visible=True\n)\n\n# set layer 2-3 port filters\nl23_port_filter = view.Layer23ProtocolPortFilter.find()\n\n# iterate over the PortFilters and enable them\nfor port_filter in l23_port_filter.PortFilters.find():\n    # set the port filter to True to enable it\n    port_filter.Enabled = True\n\n# enable statistics\nfor statistic in view.Statistic.find():\n    statistic.Enabled = True\n\n# enable the view\nview.Enabled = True\n\n# wait for data to become available\nattempts = 0\nwhile view.Data.IsReady is False and attempts < 10:\n    sleep(1)\n    attempts += 1\n\n# print the column headers\nprint(\" \".join(view.Data.ColumnCaptions))\n\n# print the snapshot data\nfor data in view.Data.PageValues:\n    for row in data:\n        print(\" \".join(row))\n"
                    },
                    {
                        "name": "traffic_flow_custom_view.py",
                        "content": "\"\"\"\nCreates a layer 2-3 traffic flow custom view\nThis sample requires a running ixnetwork instance that has traffic being transmitted.\nIt uses all possible traffic filters, port filters, enumeration filters and statistics when creating the view.\nThe last step prior to getting data should be to enable the view.\n\nSupports IxNetwork API servers:\n   - Windows, Windows Connection Mgr and Linux\n\nRequirements:\n   - Minimum IxNetwork 9.30\n   - Python 2.7 and 3+\n   - pip install requests\n   - pip install ixnetwork_restpy (minimum version 1.1.8)\n\"\"\"\n\nfrom time import sleep\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=False,\n)\nixnetwork = session_assistant.Ixnetwork\n\n\n# remove the view if it already exists\ncaption = \"Traffic Flow Custom View\"\nview = ixnetwork.Statistics.View.find(Caption=caption)\nif len(view) == 1:\n    view.remove()\n\n# create the view\nview = ixnetwork.Statistics.View.add(\n    Caption=caption, Type=\"layer23TrafficFlow\", Visible=True\n)\n\n# set filters\nl23_traffic_flow_filter = view.Layer23TrafficFlowFilter.find()\n\n# iterate over the TrafficItemFilters and enable them\nfor traffic_item_filter in l23_traffic_flow_filter.TrafficItemFilters.find():\n    # set the port filter to True to enable it\n    traffic_item_filter.Enabled = True\n\n# iterate over the PortFilters and enable them\nfor port_filter in l23_traffic_flow_filter.PortFilters.find():\n    # set the port filter to True to enable it\n    port_filter.Enabled = True\n\n# iterate over the EnumerationFilters and enable them\nfor enumeration_filter in l23_traffic_flow_filter.EnumerationFilters.find():\n    # set the port filter to True to enable it\n    enumeration_filter.Enabled = True\n\n# enable statistics\nfor statistic in view.Statistic.find():\n    statistic.Enabled = True\n\n# enable the view\nview.Enabled = True\n\n# wait for data to become available\nattempts = 0\nwhile view.Data.IsReady is False and attempts < 10:\n    sleep(1)\n    attempts += 1\n\n# print the column headers\nprint(\" \".join(view.Data.ColumnCaptions))\n\n# print the snapshot data\nfor data in view.Data.PageValues:\n    for row in data:\n        print(\" \".join(row))\n"
                    }
                ]
            }
        ]
    },
    {
        "name": "Traffic",
        "children": [
            {
                "name": "traffic_custom_stack.py",
                "content": "\"\"\"This sample demonstrates customizing a traffic item stack.\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# create two vport objects\nvport_1 = ixnetwork.Vport.add()\nvport_2 = ixnetwork.Vport.add()\n\n# create a raw traffic item\ntraffic_item = ixnetwork.Traffic.TrafficItem.add(\n    Name=\"Raw Traffic Item Sample\", TrafficType=\"raw\", TrafficItemType=\"l2L3\"\n)\nendpoint_set = traffic_item.EndpointSet.add(\n    Sources=vport_1.Protocols.find(), Destinations=vport_2.Protocols.find()\n)\n\n# append protocol templates to the traffic item\nconfig_element = traffic_item.ConfigElement.find(EndpointSetId=1)\nethernet_stack = config_element.Stack.find(StackTypeId=\"^ethernet$\")\n\n# get the protocol templates to be appended\nvlan_protocol_template = ixnetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^vlan$\")\nipv4_protocol_template = ixnetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^ipv4$\")\nudp_protocol_template = ixnetwork.Traffic.ProtocolTemplate.find(StackTypeId=\"^udp$\")\n\n# append the protocol templates and get the newly appended stack object using the returned href\nvlan_stack = config_element.Stack.read(\n    ethernet_stack.AppendProtocol(vlan_protocol_template)\n)\nipv4_stack = config_element.Stack.read(\n    vlan_stack.AppendProtocol(ipv4_protocol_template)\n)\nudp_stack = config_element.Stack.read(ipv4_stack.AppendProtocol(udp_protocol_template))\n"
            },
            {
                "name": "traffic_over_lags.py",
                "content": "\"\"\"Demonstrates how to create traffic over a lag\n\nNOTE: due to current limitations either a Lagportlacp or Lagportstaticlag must be added\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# add a source lag with multiple vports\nvports_1 = ixnetwork.Vport.add().add()\nlag_1 = ixnetwork.Lag.add(Name=\"Lag 1\", Vports=vports_1)\nlag_1.ProtocolStack.add().Ethernet.add().Lagportlacp.add()\nassert len(lag_1.Vports) == 2\n\n# add a destination lag with multiple vports\nvports_2 = ixnetwork.Vport.add().add()\nlag_2 = ixnetwork.Lag.add(Name=\"Lag 2\", Vports=vports_2)\nlag_2.ProtocolStack.add().Ethernet.add().Lagportlacp.add()\nassert len(lag_2.Vports) == 2\n\n# add lags to topologies\nethernet1 = ixnetwork.Topology.add(Ports=lag_1).DeviceGroup.add().Ethernet.add()\nethernet2 = ixnetwork.Topology.add(Ports=lag_2).DeviceGroup.add().Ethernet.add()\n\n# create a raw traffic item\ntraffic_item = ixnetwork.Traffic.TrafficItem.add(\n    Name=\"Lag Traffic Item Sample\", TrafficType=\"raw\"\n)\n\n# add the lag objects as endpoints to the traffic item\nendpoint_set = traffic_item.EndpointSet.add(Destinations=lag_2, Sources=lag_1)\nassert len(endpoint_set.Sources) == 1\nassert len(endpoint_set.Destinations) == 1\n"
            },
            {
                "name": "traffic_over_protocols.py",
                "content": "\"\"\"Demonstrates creating a traffic item that uses ipv4 endpoints.\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# create 2 ipv4 endpoints\nipv4_1 = (\n    ixnetwork.Topology.add(Vports=ixnetwork.Vport.add())\n    .DeviceGroup.add()\n    .Ethernet.add()\n    .Ipv4.add(Name=\"Ipv4 West\")\n)\nipv4_2 = (\n    ixnetwork.Topology.add(Vports=ixnetwork.Vport.add())\n    .DeviceGroup.add()\n    .Ethernet.add()\n    .Ipv4.add(Name=\"Ipv4 East\")\n)\n\n# create an ipv4 traffic item\ntraffic_item = ixnetwork.Traffic.TrafficItem.add(\n    Name=\"Ipv4 Traffic Item Sample\", TrafficType=\"ipv4\", TrafficItemType=\"l2L3\"\n)\n\n# create an endpoint set using the ipv4 objects\nendpoint_set = traffic_item.EndpointSet.add(Sources=ipv4_1, Destinations=ipv4_2)\nassert len(endpoint_set.Sources) == 1\nassert len(endpoint_set.Destinations) == 1\nassert len(traffic_item.ConfigElement.find().Stack.find(StackTypeId=\"ipv4\")) == 1\n"
            },
            {
                "name": "traffic_over_vports.py",
                "content": "\"\"\"Demonstrates creating a raw traffic item over vport endpoints.\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# create two vport objects\nvport_1 = ixnetwork.Vport.add()\nvport_2 = ixnetwork.Vport.add()\n\n# create a raw traffic item\ntraffic_item = ixnetwork.Traffic.TrafficItem.add(\n    Name=\"Raw Traffic Item Sample\", TrafficType=\"raw\", TrafficItemType=\"l2L3\"\n)\n\n# raw traffic endpoints must be Vport.Protocols objects\n# create an endpoint set using the Vport.Protocols objects\nendpoint_set = traffic_item.EndpointSet.add(\n    Sources=vport_1.Protocols.find(), Destinations=vport_2.Protocols.find()\n)\nassert len(endpoint_set.Sources) == 1\nassert len(endpoint_set.Destinations) == 1\n"
            },
            {
                "name": "traffic_scalable_sources_multicast_receivers.py",
                "content": "\"\"\"Demonstrates creating a traffic item that uses scalable sources and igmp multicast receivers.\n\n\"\"\"\n\nfrom ixnetwork_restpy import SessionAssistant\n\n\nsession_assistant = SessionAssistant(\n    IpAddress=\"127.0.0.1\",\n    UserName=\"admin\",\n    Password=\"admin\",\n    LogLevel=SessionAssistant.LOGLEVEL_INFO,\n    ClearConfig=True,\n)\nixnetwork = session_assistant.Ixnetwork\n\n# create 2 igmp endpoints\nipv4_1 = (\n    ixnetwork.Topology.add(Vports=ixnetwork.Vport.add())\n    .DeviceGroup.add()\n    .Ethernet.add()\n    .Ipv4.add()\n)\nigmp_host = ipv4_1.IgmpHost.add(Name=\"Igmp Host\")\nipv4_2 = (\n    ixnetwork.Topology.add(Vports=ixnetwork.Vport.add().add().add())\n    .DeviceGroup.add()\n    .Ethernet.add()\n    .Ipv4.add()\n)\nigmp_querier = ipv4_2.IgmpQuerier.add(Name=\"Igmp Querier\")\n\n# create a scalable sources object to be used in creating traffic\n# arg1=ngpfObjectReference arg2=1 based port index, arg3=portCount, arg4=startingDeviceIndex, arg5=deviceCount\nscalable_sources = [\n    {\"arg1\": ipv4_2.href, \"arg2\": 1, \"arg3\": 3, \"arg4\": 1, \"arg5\": 2},\n    {\"arg1\": ipv4_2.href, \"arg2\": 1, \"arg3\": 3, \"arg4\": 9, \"arg5\": 2},\n]\n# create a multicast receiver object to be used in creating traffic\n# arg1=IgmpMcastIPv4GroupList.href, arg2=0 based port index, arg3=0 based host index, arg4=0 based group or prune/join index\nmulticast_receivers = [\n    {\"arg1\": igmp_host.IgmpMcastIPv4GroupList.href, \"arg2\": 0, \"arg3\": 3, \"arg4\": 0},\n    {\"arg1\": igmp_host.IgmpMcastIPv4GroupList.href, \"arg2\": 0, \"arg3\": 4, \"arg4\": 0},\n    {\"arg1\": igmp_host.IgmpMcastIPv4GroupList.href, \"arg2\": 0, \"arg3\": 6, \"arg4\": 0},\n    {\"arg1\": igmp_host.IgmpMcastIPv4GroupList.href, \"arg2\": 0, \"arg3\": 9, \"arg4\": 0},\n]\n\n# create a traffic item using the scalable sources and multicast receivers\ntraffic_item = ixnetwork.Traffic.TrafficItem.add(\n    Name=\"Ipv4 Traffic Item Sample\", TrafficType=\"ipv4\", TrafficItemType=\"l2L3\"\n)\nendpoint_set = traffic_item.EndpointSet.add(\n    ScalableSources=scalable_sources, MulticastReceivers=multicast_receivers\n)\nassert len(endpoint_set.MulticastReceivers) == 4\nassert len(endpoint_set.ScalableSources) == 2\nassert len(traffic_item.ConfigElement.find().Stack.find(StackTypeId=\"ipv4\")) == 1\n"
            }
        ]
    }
]